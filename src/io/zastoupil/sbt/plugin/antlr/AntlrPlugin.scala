package io.zastoupil.sbt.plugin.antlr


import org.antlr.v4.Tool
import sbt.Keys._
import sbt._

object AntlrPlugin extends AutoPlugin {

  object autoImport {
    // - main task
    lazy val antlr = taskKey[Unit]("generates antlr parsers")

    // - source & target path calculation
    lazy val antlrTargets = taskKey[Map[File, (File, String)]]("generates a map of antlr source file targets to output directory and package name")
    lazy val antlrSourceFiles = taskKey[Seq[File]](s"filters the $antlrSourceDirectory to find antlr files")
    lazy val antlrRelativePaths = taskKey[Seq[String]](s"uses the $antlrSourceDirectory and $antlrSourceFiles to determine relative paths of antlr source files")
    lazy val antlrOutputDirectories = taskKey[Seq[File]](s"uses $antlrBaseOutputDirectory and $antlrRelativePaths to determine the locations of specific ")
    lazy val antlrPackageNames = taskKey[Seq[String]](s"uses $antlrRelativePaths to determine the package names for generated classes")

    // - cli utility
    lazy val antlrArgumentString = taskKey[String]("generate a reusable commandline argument string that represents all antlr settings")
    lazy val antlrGeneratedFileOptions = taskKey[Seq[String]]("generates commandline argument strings for generated file properties.")
    lazy val antlrErrorAndReportingOptions = taskKey[Seq[String]]("generates commandline argument strings for error and reporting properties.")
    lazy val antlrExtensionOptions = taskKey[Seq[String]]("generates commandline argument strings for antlr's extension options")

    // - source directory
    lazy val antlrSourceDirectory = settingKey[File](s"the source directory to be compiled using $antlr")

    // - generated file options
    lazy val antlrEncoding = settingKey[Option[String]](s"if specified, enforces a specific encoding for the source files generated by $antlr")
    lazy val antlrBaseOutputDirectory = settingKey[File](s"the base directory to store source files generated by $antlr. Generated files will be placed in the appropriate packages.")
    lazy val antlrLibDirectory = settingKey[Option[File]](s"the library of grammar files to be used by $antlr during compilation")
    lazy val antlrGenerateDiagrams = settingKey[Boolean](s"if true, $antlr will generate rule augmented network diagrams")
    lazy val antlrGenerateListener = settingKey[Boolean](s"if true, $antlr generates a parse tree listener.")
    lazy val antlrGenerateVisitor = settingKey[Boolean](s"if true, $antlr generates a parse tree visitor.")
    lazy val antlrGenerateFileDependencies = settingKey[Boolean](s"if true, $antlr will generate file dependencies")

    // - error and reporting options
    lazy val antlrMessageFormat = settingKey[Option[String]](s"if specified, configures the message format used by $antlr")
    lazy val antlrLongMessages = settingKey[Boolean](s"if true, $antlr shows exception details where available")
    lazy val antlrTreatWarningsAsErrors = settingKey[Boolean](s"if true, $antlr will treat warnings as errors")

    // - extension options
    lazy val antlrOptions = settingKey[Map[String, String]](s"grammar-level options to be passed to the commandline tool used by $antlr")
    lazy val antlrLaunchStringTemplateVisualizer = settingKey[Boolean](s"if true, $antlr will launch the string template visualizer on generated code")
    lazy val antlrWaitOnVisualizer = settingKey[Boolean](s"if true, $antlr will wait for the string template visualizer to close before continuing")
    lazy val antlrForceAtnSimulation = settingKey[Boolean](s"if true, $antlr will force the use of ATN simulations for all predictions")
    lazy val antlrLog = settingKey[Boolean](s"if true, $antlr will dump log messages to file")

  }

  import autoImport._

  override lazy val buildSettings = Seq(

    // ANTLR runtime enabled in target project by default
    libraryDependencies += "org.antlr" % "antlr4-runtime" % "4.5",

    // - source directory
    antlrSourceDirectory := baseDirectory.value / "antlr",
    // - source directory is registered with sbt's unmanaged source directories in compile and test by default
    (unmanagedSourceDirectories in Compile) += antlrSourceDirectory.value,
    (unmanagedSourceDirectories in Test) += antlrSourceDirectory.value,

    // - output directory
    antlrBaseOutputDirectory := baseDirectory.value / "generated",
    // - output directory is registered with sbt's managed source directories in compile and test by default
    (managedSourceDirectories in Compile) += antlrBaseOutputDirectory.value,
    (managedSourceDirectories in Test) += antlrBaseOutputDirectory.value,

    // - generated file options
    antlrEncoding := None,
    antlrLibDirectory := None,
    antlrGenerateDiagrams := false,
    antlrGenerateListener := true,
    antlrGenerateVisitor := true,
    antlrGenerateFileDependencies := false,

    // - error and reporting options
    antlrMessageFormat := None,
    antlrLongMessages := false,
    antlrTreatWarningsAsErrors := false,

    // - extension options
    antlrOptions := Map[String, String](),
    antlrLaunchStringTemplateVisualizer := false,
    antlrWaitOnVisualizer := false,
    antlrForceAtnSimulation := false,
    antlrLog := false,

    // - main task
    antlr := {
      antlrTargets.value.foreach {
        case (source: File, (outputDirectory: File, packageName: String)) =>
          Tool.main(s"$source -o $outputDirectory -package $packageName ${antlrArgumentString.value}".split(" "))
      }
    },

    // - compile task depends on antlr by default
    (compile in Compile) <<= (compile in Compile).dependsOn(antlr),
    (compile in Test) <<= (compile in Test).dependsOn(antlr),

    // - source & target path calculation
    antlrTargets := Map(antlrSourceFiles.value.zip(antlrOutputDirectories.value.zip(antlrPackageNames.value)): _*),
    antlrSourceFiles := (antlrSourceDirectory.value ** "*.g4").get,
    antlrRelativePaths := antlrSourceFiles.value.map(f => IO.relativize(antlrSourceDirectory.value, f.getParentFile)).filter(_.isDefined).map(_.get),
    antlrOutputDirectories := antlrRelativePaths.value.map(antlrBaseOutputDirectory.value / _),
    antlrPackageNames := antlrRelativePaths.value.map(_.replace(java.io.File.separatorChar, '.')),

    // - cli utility
    antlrArgumentString := (antlrGeneratedFileOptions.value ++ antlrErrorAndReportingOptions.value ++ antlrExtensionOptions.value).mkString(" "),

    antlrGeneratedFileOptions := Seq(
      s"${if (antlrEncoding.value.isDefined) s"-encoding ${antlrEncoding.value.get}" else ""}",
      s"${if (antlrLibDirectory.value.isDefined) s"-lib ${antlrLibDirectory.value.get}" else ""}",
      s"${if (antlrGenerateDiagrams.value) "-atn" else ""}",
      s"${if (antlrGenerateListener.value) "-listener" else "-no-listener"}",
      s"${if (antlrGenerateVisitor.value) "-visitor" else "-no-visitor"}",
      s"${if (antlrGenerateFileDependencies.value) "-depend" else ""}"
    ).filter(_ != null).map(_.trim).filter(_.nonEmpty),

    antlrErrorAndReportingOptions := Seq(
      s"${if (antlrMessageFormat.value.isDefined) s"-message-format ${antlrMessageFormat.value.get}" else ""}",
      s"${if (antlrLongMessages.value) "-long-messages" else ""}",
      s"${if (antlrTreatWarningsAsErrors.value) "-Werror" else ""}"
    ).filter(_ != null).map(_.trim).filter(_.nonEmpty),

    antlrExtensionOptions :=
      antlrOptions.value.map {
        case (key: String, value: String) =>
          s"-D$key=$value"
        case _ => ""
      }.toSeq ++ Seq(
        s"${if (antlrLaunchStringTemplateVisualizer.value) "-XdbgST" else ""}",
        s"${if (antlrWaitOnVisualizer.value) "-XdbgSTWait" else ""}",
        s"${if (antlrForceAtnSimulation.value) "-Xforce-atn" else ""}",
        s"${if (antlrLog.value) "-XLog" else ""}"
      ).filter(_ != null).map(_.trim).filter(_.nonEmpty)

  )

}
