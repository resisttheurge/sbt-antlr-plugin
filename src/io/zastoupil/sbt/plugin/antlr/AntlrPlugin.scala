package io.zastoupil.sbt.plugin.antlr


import org.antlr.v4.Tool
import sbt.Keys._
import sbt._

object AntlrPlugin extends AutoPlugin {

  object autoImport {
    // - main task
    lazy val antlr = taskKey[Unit]("generates antlr parsers")

    // - source directory
    lazy val antlrSourceDirectory = settingKey[File](s"the source directory to be compiled using $antlr")
    lazy val antlrBaseOutputDirectory = settingKey[File]("the base directory to store source files generated by antlr. Generated files will be placed in the appropriate packages.")

    // - generated file options
    lazy val antlrEncoding = settingKey[Option[String]]("if specified, enforces a specific encoding for the source files generated by antlr")
    lazy val antlrLibDirectory = settingKey[Option[File]]("the library of grammar files to be used by antlr during compilation")
    lazy val antlrGenerateDiagrams = settingKey[Boolean]("if true, antlr will generate rule augmented network diagrams")
    lazy val antlrGenerateListener = settingKey[Boolean]("if true, antlr generates a parse tree listener.")
    lazy val antlrGenerateVisitor = settingKey[Boolean]("if true, antlr generates a parse tree visitor.")
    lazy val antlrGenerateFileDependencies = settingKey[Boolean]("if true, antlr will generate file dependencies")

    // - error and reporting options
    lazy val antlrMessageFormat = settingKey[Option[String]]("if specified, configures the message format used by antlr")
    lazy val antlrLongMessages = settingKey[Boolean]("if true, antlr shows exception details where available")
    lazy val antlrTreatWarningsAsErrors = settingKey[Boolean]("if true, antlr will treat warnings as errors")

    // - extension options
    lazy val antlrOptions = settingKey[Map[String, String]]("grammar-level options to be passed to the commandline tool used by antlr")
    lazy val antlrLaunchStringTemplateVisualizer = settingKey[Boolean](s"if true, antlr will launch the string template visualizer on generated code")
    lazy val antlrWaitOnVisualizer = settingKey[Boolean]("if true, antlr will wait for the string template visualizer to close before continuing")
    lazy val antlrForceAtnSimulation = settingKey[Boolean]("if true, antlr will force the use of ATN simulations for all predictions")
    lazy val antlrLog = settingKey[Boolean]("if true, antlr will dump log messages to file")

  }

  import autoImport._

  override lazy val projectSettings = Seq(

    // ANTLR runtime enabled in target project by default
    libraryDependencies += "org.antlr" % "antlr4-runtime" % "4.5",

    antlrSourceDirectory := baseDirectory.value / "antlr",
    antlrBaseOutputDirectory := baseDirectory.value / "generated",

    // - generated file options
    antlrEncoding := None,
    antlrLibDirectory := None,
    antlrGenerateDiagrams := false,
    antlrGenerateListener := true,
    antlrGenerateVisitor := true,
    antlrGenerateFileDependencies := false,

    // - error and reporting options
    antlrMessageFormat := None,
    antlrLongMessages := false,
    antlrTreatWarningsAsErrors := false,

    // - extension options
    antlrOptions := Map[String, String](),
    antlrLaunchStringTemplateVisualizer := false,
    antlrWaitOnVisualizer := false,
    antlrForceAtnSimulation := false,
    antlrLog := false,

    // - main task
    antlr := {
      AntlrTask(
        AntlrSettings(
          antlrSourceDirectory.value,
          antlrBaseOutputDirectory.value,
          antlrEncoding.value,
          antlrLibDirectory.value,
          antlrGenerateDiagrams.value,
          antlrGenerateListener.value,
          antlrGenerateVisitor.value,
          antlrGenerateFileDependencies.value,
          antlrMessageFormat.value,
          antlrLongMessages.value,
          antlrTreatWarningsAsErrors.value,
          antlrLaunchStringTemplateVisualizer.value,
          antlrWaitOnVisualizer.value,
          antlrForceAtnSimulation.value,
          antlrLog.value,
          antlrOptions.value
        ))
        .apply()
    }
  )
}

case class AntlrTask(settings: AntlrSettings) {

  def apply(): Unit = settings.targets.foreach {
    (target: AntlrTarget) => {
      Tool.main((target.arguments ++ settings.arguments).mkString(" ").split(" "))
    }
  }

}

case class AntlrSettings(sourceDirectory: File,
                         outputDirectory: File,
                         encoding: Option[String],
                         libDirectory: Option[File],
                         generateDiagrams: Boolean,
                         generateListener: Boolean,
                         generateVisitor: Boolean,
                         generateFileDependencies: Boolean,
                         messageFormat: Option[String],
                         longMessages: Boolean,
                         treatWarningsAsErrors: Boolean,
                         launchStringTemplateVisualizer: Boolean,
                         waitOnVisualizer: Boolean,
                         forceAtnSimulation: Boolean,
                         log: Boolean,
                         options: Map[String, String]) {

  lazy val targets = sources map {
    (sourceFile: File) => {
      val parent = sourceFile.getParentFile
      val relativePath = IO.relativize(sourceDirectory, parent)

      val targetDirectory = if(relativePath.isDefined) outputDirectory / relativePath.get else outputDirectory
      val packageName = relativePath.map(_.replace(java.io.File.separatorChar, '.'))

      AntlrTarget(sourceFile, targetDirectory, packageName)
    }
  }

  lazy val sources: Seq[File] = (sourceDirectory ** "*.g4").get

  lazy val arguments =
    (Seq(
      if (encoding.isDefined) s"-encoding ${encoding.get}" else "",
      if (libDirectory.isDefined) s"-lib ${libDirectory.get}" else "",
      if (generateDiagrams) "-atn" else "",
      if (generateListener) "-listener" else "-no-listener",
      if (generateVisitor) "-visitor" else "-no-visitor",
      if (generateFileDependencies) "-depend" else "",
      if (messageFormat.isDefined) s"-message-format ${messageFormat.get}" else "",
      if (longMessages) "-long-messages" else "",
      if (treatWarningsAsErrors) "-Werror" else "",
      if (launchStringTemplateVisualizer) "-XdbgST" else "",
      if (waitOnVisualizer) "-XdbgSTWait" else "",
      if (forceAtnSimulation) "-Xforce-atn" else "",
      if (log) "-XLog" else ""
    ) ++ options.map { case (key: String, value: String) => s"-D$key=$value" }.toSeq)

      .filter(_ != null).map(_.trim).filter(_.nonEmpty)

}

case class AntlrTarget(sourceFile: File,
                       targetDirectory: File,
                       packageName: Option[String]) {

  lazy val arguments =
    Seq(
      sourceFile.toString,
      s"-lib ${sourceFile.getParent}",
      s"-o $targetDirectory",
      if (packageName.isDefined) s"-package ${packageName.get}" else ""
    ).filter(_ != null).map(_.trim).filter(_.nonEmpty)

}